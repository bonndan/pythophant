<?php
/**
 * PropertyToken
 * 
 * token that triggers getter-setter generation on class members
 * 
 * <code>
 * class TestClass
 * 
 *     property private myProperty
 * </code>
 * 
 * @package PythoPhant 
 */
class PropertyToken extends CustomGenericToken implements MacroConsumer
{
    /**
     * @var string 
     */
    const TOKEN_NAME  = 'T_PROPERTY';
    const TOKEN_VALUE = 'property';

    /**
     * scanner instance
     * @var Scanner 
     */
    private $scanner;
    
    /**
     * is not rendered
     * 
     * @return null 
     */
    public function getContent()
    {
        return NULL;
    }
    
    /**
     * this generic implementation does not affect the token list
     * 
     * @param TokenList $tokenList
     * 
     * @return void 
     */
    public function affectTokenList(TokenList $tokenList)
    {
        $typeToken = $tokenList->getNextNonWhitespace($this);
        
        $nextToken = $tokenList->getNextNonWhitespace($typeToken);
        if (!$nextToken instanceof StringToken) {
            throw new LogicException (
                'accessible must be followed by  return type and then variable name, not ' . $nextToken->getContent()
            );
        }
        
        $varName = $nextToken->getContent();
        $typeToken->setContent('');
        $type = $typeToken->getContent(true);
        
        $this->generateGetter($tokenList, $type, $varName);
        $this->generateSetter($tokenList, $type, $varName);
        
    }
    
    /**
     * pushes a complete getter function with type casting to end of the token list
     * 
     * @param TokenList $tokenList
     * @param string    $type
     * @param string    $varName 
     */
    private function generateGetter(TokenList $tokenList, $type, $varName)
    {
        $file = new SplFileObject(
            PATH_PYTHOPHANT_MACROS . DIRECTORY_SEPARATOR . 'propertyGetter.pp'
        );
        $macro = new PythoPhant_Macro($file);
        $macro->setParams(array($type, $varName));
        $this->scanner->scanSource($macro->getSource());
        $macroTokens = $this->scanner->getTokenList();
        
        foreach ($macroTokens as $token) {
            $tokenList->pushToken($token);
        }
    }
    
    /**
     * pushes a complete getter function with type casting to end of the token list
     * 
     * @param TokenList $tokenList
     * @param string    $type
     * @param string    $varName 
     */
    private function generateSetter(TokenList $tokenList, $type, $varName)
    {
        $tokenFactory = new PythoPhant_TokenFactory();
        
        $setter = array(
            IndentationToken::create(1),
            $tokenFactory->createToken('T_DOC_COMMENT', "/** autogenerated setter @return self*/". PHP_EOL),
            IndentationToken::create(1),
            $tokenFactory->createToken('T_PUBLIC', 'public '),
            $tokenFactory->createToken('T_FUNCTION', 'function '),
            $tokenFactory->createToken('T_FUNCTION', 'set'.ucfirst($varName)),
            $tokenFactory->createToken(Token::T_OPEN_BRACE),
            $tmp = !in_array($type, PythoPhant_Grammar::$returnValues)?
                $tokenFactory->createToken('T_STRING', $type.' '):
                $tokenFactory->createToken('T_WHITESPACE', '')
                ,
            $tokenFactory->createToken('T_STRING', $varName),
            $tokenFactory->createToken(Token::T_CLOSE_BRACE),
            $tokenFactory->createToken('T_NEWLINE'),
            IndentationToken::create(2),
            $tokenFactory->createToken('T_THIS', 'this->'),
            $tokenFactory->createToken('T_VARIABLE', $varName),
            $tokenFactory->createToken('T_WHITESPACE', ' '),
            $tokenFactory->createToken('T_ASSIGN', '='),
            $tokenFactory->createToken('T_WHITESPACE', ' '),
            $tmp = in_array($type, PythoPhant_Grammar::$returnValues)?
                $tokenFactory->createToken('T_STRING',  '(' . $type . ')'):
                $tokenFactory->createToken('T_WHITESPACE', '')
                ,
            $tokenFactory->createToken('T_STRING', $varName),
            $tokenFactory->createToken('T_NEWLINE', PHP_EOL),
            IndentationToken::create(2),
            $tokenFactory->createToken('T_RETURN', 'return '),
            $tokenFactory->createToken('T_STRING', 'this'),
            $tokenFactory->createToken('T_NEWLINE', PHP_EOL),
        );
        foreach ($setter as $token) {
            $tokenList->pushToken($token);
        }
    }
    
    /**
     * scanner injection
     * 
     * @param Scanner $scanner 
     */
    public function setScanner(Scanner $scanner)
    {
        $this->scanner = $scanner;
    }

}
