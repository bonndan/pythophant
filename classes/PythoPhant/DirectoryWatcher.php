<?php /** generated by PythoPhant on 2012/03/31 17:57:17 from DirectoryWatcher. #71df7b3a6f5808c5c318467d2c62b876 */
/**
 * PythoPhant_DirectoryWatcher
 * 
 * recursively scans directories for pp files and notifies observers on change
 */
class PythoPhant_DirectoryWatcher
extends PythoPhant_AbstractSubject
implements PythoPhant_Subject
{
    /**
     * directories to watch
     * @var array(string) 
     */
    private $directories = array();

    /**
     * observed files
     * @var array
     */
    private $files = array();

    /**
     * milliseconds, no automatic polling by default
     * @var int 
     */
    private $pollingInterval = -1;

    /**
     * add a directory path to watch
     * 
     * @param string $dir
     * 
     * @return \PythoPhant_DirectoryWatcher  
     */
    public function addDirectory($dir)
    {
        if ((!is_dir($dir))) {
            return $this->notify(new PythoPhant_Event_Error('not a directory', $dir));
        }

        $this->directories[] = $dir;
        $this->directories = array_unique($this->directories);

        return $this;
    }

    /**
     * loop over the directories, store file mtime for all watched files 
     * 
     * @param int pollingInterval
     * 
     * @return void
     */
    public function run($pollingInterval = null)
    {
        if ($pollingInterval !== null) {
            $this->pollingInterval = $pollingInterval;
        }

        $files = array();
        foreach ($this->directories as $dir) {
            $files = array_merge($files, $this->scanRecursive($dir));
        }

        foreach ($files as $filename) {
            $lastChange = filemtime($filename);
            if (isset($this->files[$filename])) {
                if (($this->files[$filename] - $lastChange) != 0) {
                    $this->notify(new PythoPhant_FileChangedEvent($filename));
                }

            }

            else {
                $this->files[$filename] = $lastChange;
                $this->notify(new PythoPhant_Event_Info('Watching new file',$filename));
            }

        }

        if ($this->pollingInterval > -1) {
            sleep($this->pollingInterval / 1000);
            call_user_func(array($this, 'run'));
        }

    }

    /**
     * scan recursive
     *
     * @param string pattern
     * 
     * @return array
     */
    private function scanRecursive($path)
    {
        $files = array();
        foreach (new DirectoryIterator($path) as $file) {
            if ($file->getExtension() == 'pp') {
                $files[] = $file->getRealPath();
            }

            elseif ($file->isDir() && ! in_array($file->getBasename(), array('.', '..'))) {
                $files = array_merge($files, $this->scanRecursive($file->getRealPath()));
            }

        }

        return $files;
        
    }

}

